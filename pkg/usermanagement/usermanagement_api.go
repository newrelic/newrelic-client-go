// Code generated by tutone: DO NOT EDIT
package usermanagement

import "context"

func (a *Usermanagement) UserManagementCreateUser(
	createUserOptions UserManagementCreateUser,
) (*UserManagementCreateUserPayload, error) {
	return a.UserManagementCreateUserWithContext(context.Background(),
		createUserOptions,
	)
}

func (a *Usermanagement) UserManagementCreateUserWithContext(
	ctx context.Context,
	createUserOptions UserManagementCreateUser,
) (*UserManagementCreateUserPayload, error) {

	resp := UserManagementCreateUserQueryResponse{}
	vars := map[string]interface{}{
		"createUserOptions": createUserOptions,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, UserManagementCreateUserMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.UserManagementCreateUserPayload, nil
}

type UserManagementCreateUserQueryResponse struct {
	UserManagementCreateUserPayload UserManagementCreateUserPayload `json:"UserManagementCreateUser"`
}

const UserManagementCreateUserMutation = `mutation(
	$createUserOptions: UserManagementCreateUser!,
) { userManagementCreateUser(
	createUserOptions: $createUserOptions,
) {
	createdUser {
		authenticationDomainId
		email
		id
		name
		type {
			displayName
			id
		}
	}
} }`

func (a *Usermanagement) UserManagementDeleteUser(
	deleteUserOptions UserManagementDeleteUser,
) (*UserManagementDeleteUserPayload, error) {
	return a.UserManagementDeleteUserWithContext(context.Background(),
		deleteUserOptions,
	)
}

func (a *Usermanagement) UserManagementDeleteUserWithContext(
	ctx context.Context,
	deleteUserOptions UserManagementDeleteUser,
) (*UserManagementDeleteUserPayload, error) {

	resp := UserManagementDeleteUserQueryResponse{}
	vars := map[string]interface{}{
		"deleteUserOptions": deleteUserOptions,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, UserManagementDeleteUserMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.UserManagementDeleteUserPayload, nil
}

type UserManagementDeleteUserQueryResponse struct {
	UserManagementDeleteUserPayload UserManagementDeleteUserPayload `json:"UserManagementDeleteUser"`
}

const UserManagementDeleteUserMutation = `mutation(
	$deleteUserOptions: UserManagementDeleteUser!,
) { userManagementDeleteUser(
	deleteUserOptions: $deleteUserOptions,
) {
	deletedUser {
		id
	}
} }`

func (a *Usermanagement) UserManagementUpdateUser(
	updateUserOptions UserManagementUpdateUser,
) (*UserManagementUpdateUserPayload, error) {
	return a.UserManagementUpdateUserWithContext(context.Background(),
		updateUserOptions,
	)
}

func (a *Usermanagement) UserManagementUpdateUserWithContext(
	ctx context.Context,
	updateUserOptions UserManagementUpdateUser,
) (*UserManagementUpdateUserPayload, error) {

	resp := UserManagementUpdateUserQueryResponse{}
	vars := map[string]interface{}{
		"updateUserOptions": updateUserOptions,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, UserManagementUpdateUserMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.UserManagementUpdateUserPayload, nil
}

type UserManagementUpdateUserQueryResponse struct {
	UserManagementUpdateUserPayload UserManagementUpdateUserPayload `json:"UserManagementUpdateUser"`
}

const UserManagementUpdateUserMutation = `mutation(
	$updateUserOptions: UserManagementUpdateUser!,
) { userManagementUpdateUser(
	updateUserOptions: $updateUserOptions,
) {
	user {
		email
		emailVerificationState
		groups {
			nextCursor
			totalCount
		}
		id
		lastActive
		name
		timeZone
		type {
			displayName
			id
		}
	}
} }`

// An "authentication domain" is a grouping of New Relic users governed by the same user management settings, like how they're provisioned (added and updated), how they're authenticated (logged in), session settings, and how user upgrades are managed.
func (a *Usermanagement) GetAuthenticationDomains(
	cursor string,
	iD []string,
) (*UserManagementAuthenticationDomains, error) {
	return a.GetAuthenticationDomainsWithContext(context.Background(),
		cursor,
		iD,
	)
}

// An "authentication domain" is a grouping of New Relic users governed by the same user management settings, like how they're provisioned (added and updated), how they're authenticated (logged in), session settings, and how user upgrades are managed.
func (a *Usermanagement) GetAuthenticationDomainsWithContext(
	ctx context.Context,
	cursor string,
	iD []string,
) (*UserManagementAuthenticationDomains, error) {

	resp := authenticationDomainsResponse{}
	vars := map[string]interface{}{
		"cursor": cursor,
		"id":     iD,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, getAuthenticationDomainsQuery, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.Actor.Organization.UserManagement.AuthenticationDomains, nil
}

const getAuthenticationDomainsQuery = `query(
	$id: [ID!],
) { actor { organization { userManagement { authenticationDomains(
	id: $id,
) {
	authenticationDomains {
		id
		name
		provisioningType
	}
	nextCursor
	totalCount
} } } } }`

// Code generated by tutone: DO NOT EDIT
package usermanagement

import "context"

// A mutation for creating a group in an authentication domain.
func (a *Usermanagement) UserManagementCreateGroup(
	createGroupOptions UserManagementCreateGroup,
) (*UserManagementCreateGroupPayload, error) {
	return a.UserManagementCreateGroupWithContext(context.Background(),
		createGroupOptions,
	)
}

// A mutation for creating a group in an authentication domain.
func (a *Usermanagement) UserManagementCreateGroupWithContext(
	ctx context.Context,
	createGroupOptions UserManagementCreateGroup,
) (*UserManagementCreateGroupPayload, error) {

	resp := UserManagementCreateGroupQueryResponse{}
	vars := map[string]interface{}{
		"createGroupOptions": createGroupOptions,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, UserManagementCreateGroupMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.UserManagementCreateGroupPayload, nil
}

type UserManagementCreateGroupQueryResponse struct {
	UserManagementCreateGroupPayload UserManagementCreateGroupPayload `json:"UserManagementCreateGroup"`
}

const UserManagementCreateGroupMutation = `mutation(
	$createGroupOptions: UserManagementCreateGroup,
) { userManagementCreateGroup(
	createGroupOptions: $createGroupOptions,
) {
	group {
		displayName
		id
		users {
			nextCursor
			totalCount
		}
	}
} }`

// A mutation for creating a user in an authentication domain.
func (a *Usermanagement) UserManagementCreateUser(
	createUserOptions UserManagementCreateUser,
) (*UserManagementCreateUserPayload, error) {
	return a.UserManagementCreateUserWithContext(context.Background(),
		createUserOptions,
	)
}

// A mutation for creating a user in an authentication domain.
func (a *Usermanagement) UserManagementCreateUserWithContext(
	ctx context.Context,
	createUserOptions UserManagementCreateUser,
) (*UserManagementCreateUserPayload, error) {

	resp := UserManagementCreateUserQueryResponse{}
	vars := map[string]interface{}{
		"createUserOptions": createUserOptions,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, UserManagementCreateUserMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.UserManagementCreateUserPayload, nil
}

type UserManagementCreateUserQueryResponse struct {
	UserManagementCreateUserPayload UserManagementCreateUserPayload `json:"UserManagementCreateUser"`
}

const UserManagementCreateUserMutation = `mutation(
	$createUserOptions: UserManagementCreateUser!,
) { userManagementCreateUser(
	createUserOptions: $createUserOptions,
) {
	createdUser {
		authenticationDomainId
		email
		id
		name
	}
} }`

// An "authentication domain" is a grouping of New Relic users governed by the same user management settings, like how they're provisioned (added and updated), how they're authenticated (logged in), session settings, and how user upgrades are managed.
func (a *Usermanagement) GetAuthenticationDomains(
	cursor string,
	iD []string,
) (*UserManagementAuthenticationDomains, error) {
	return a.GetAuthenticationDomainsWithContext(context.Background(),
		cursor,
		iD,
	)
}

// An "authentication domain" is a grouping of New Relic users governed by the same user management settings, like how they're provisioned (added and updated), how they're authenticated (logged in), session settings, and how user upgrades are managed.
func (a *Usermanagement) GetAuthenticationDomainsWithContext(
	ctx context.Context,
	cursor string,
	iD []string,
) (*UserManagementAuthenticationDomains, error) {

	resp := authenticationDomainsResponse{}
	vars := map[string]interface{}{
		"cursor": cursor,
		"id":     iD,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, getAuthenticationDomainsQuery, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.Actor.Organization.UserManagement.AuthenticationDomains, nil
}

const getAuthenticationDomainsQuery = `query(
	$id: [ID!],
) { actor { organization { userManagement { authenticationDomains(
	id: $id,
) {
	authenticationDomains {
		id
		name
		provisioningType
	}
	nextCursor
	totalCount
} } } } }`

// Code generated by tutone: DO NOT EDIT
package {{.PackageName | lower}}

{{- if gt (len .Imports) 0 }}
import(
  {{- range .Imports}}
  "{{.}}"
  {{- end}}
)
{{- end}}

{{- range .Enums }}
{{ .Description }}
type {{ .Name }} string
{{ $typeName := .Name }}

var {{.Name}}Types = struct {
  {{- range .Values }}
  {{-   if ne .Description "" }}
  {{      .Description }}
  {{-   end }}
  {{   .Name }} {{ $typeName }}
  {{- end}}
}{
  {{- range .Values }}
  {{-   if ne .Description "" }}
  {{      .Description }}
  {{-   end }}
  {{ .Name }}: "{{ .Name }}",
  {{- end}}
}
{{- end }}

{{- range .Types }}
{{ .Description }}
{{- $typeName := .Name }}
type {{.Name}} struct {
  {{- range .Fields }}
  {{-   if ne .Description "" }}
  {{      .Description }}
  {{-   end }}
  {{    .Name }} {{ .Type }} {{ .Tags }}
  {{- end}}
}
{{-  if .GenerateGetters }}
{{-   range .Fields }}
// Get{{ .Name }} returns a pointer to the value of {{ .Name }} from {{ $typeName }}
func (x {{ $typeName }}) Get{{ .Name}}() {{ .Type }} {
  return x.{{ .Name }}
}
{{-    end }}
{{-  end }}

{{   range .Implements }}
func (x *{{ $typeName }}) Implements{{ . }}() {}
{{   end }}

{{-  if .SpecialUnmarshal }}
// special
func (x *{{ $typeName }}) UnmarshalJSON(b []byte) error {
  var objMap map[string]*json.RawMessage
  err := json.Unmarshal(b, &objMap)
  if err != nil {
    return err
  }

  for k, v := range objMap {
    if v == nil {
      continue
    }

    switch k {
  {{- range .Fields }}
    {{- $field := . }}
    case "{{ .TagKey }}":
    {{- if .IsInterface }}
      if v == nil {
        continue
      }
      {{- if .IsList }}
        var rawMessage{{ .Name }} []*json.RawMessage
        err = json.Unmarshal(*v, &rawMessage{{ .Name }})
        if err != nil {
          return err
        }

        for _, m := range rawMessage{{ .Name }} {
          {{- if contains "." $field.TypeName }}
          {{-   $m := split "." $field.TypeName }}
          xxx, err := {{ $m._0 }}.Unmarshal{{ $m._1 }}Interface(*m)
          {{- else }}
          xxx, err := Unmarshal{{ $field.TypeName }}Interface(*m)
          {{- end }}
          if err != nil {
            return err
          }

          if xxx != nil {
            x.{{ $field.Name }} = append(x.{{ $field.Name }}, *xxx)
          }
        }


      {{- else }}
        {{- if contains "." $field.TypeName }}
        {{-   $m := split "." $field.TypeName }}
        xxx, err := {{ $m._0 }}.Unmarshal{{ $m._1 }}Interface(*v)
        {{- else }}
        xxx, err := Unmarshal{{ $field.TypeName }}Interface(*v)
        {{- end }}
        if err != nil {
          return err
        }

        if xxx != nil {
          x.{{ $field.Name }} = *xxx
        }
      {{- end }}
    {{- else }}
      err = json.Unmarshal(*v, &x.{{ .Name }})
      if err != nil {
        return err
      }
    {{- end }}
  {{- end }}
    }
  }

  return nil
}
{{   end}}
{{ end }}

{{- range .Scalars }}
{{-   if ne .Description "" }}
{{      .Description }}
{{-   end }}
type {{.Name}} {{.Type}}
{{- end }}

{{- range .Interfaces }}
{{- $interfaceType := . }}
{{-   if ne .Description "" }}
{{      .Description }}
{{-   end }}
type {{ $interfaceType.Name }}Interface interface{
  {{- range $m := .Methods }}
  {{ $m }}
  {{- end }}
}

// Unmarshal{{ $interfaceType.Name }}Interface unmarshals the interface into the correct type
// based on __typename provided by GraphQL
func Unmarshal{{ $interfaceType.Name }}Interface(b []byte) (*{{ $interfaceType.Name }}Interface, error) {
  var err error

  var rawMessage{{ $interfaceType.Name }} map[string]*json.RawMessage
  err = json.Unmarshal(b, &rawMessage{{ $interfaceType.Name }})
  if err != nil {
    return nil, err
  }

  // Nothing to unmarshal
  if len(rawMessage{{ $interfaceType.Name }}) < 1 {
    return nil, nil
  }

  var typeName string

  if rawTypeName, ok := rawMessage{{ $interfaceType.Name }}["__typename"]; ok {
    err = json.Unmarshal(*rawTypeName, &typeName)
    if err != nil {
      return nil, err
    }

    switch typeName {
  {{- range .PossibleTypes }}
    case "{{ .GraphQLName }}":
      var interfaceType {{ .GoName }}
      err = json.Unmarshal(b, &interfaceType)
      if err != nil {
        return nil, err
      }

      var xxx {{ $interfaceType.Name }}Interface = &interfaceType

      return &xxx, nil
  {{- end }}
    }
  } else {
    keys := []string{}
    for k := range rawMessage{{ $interfaceType.Name }} {
      keys = append(keys, k)
    }
    return nil, fmt.Errorf("interface {{ $interfaceType.Name }} did not include a __typename field for inspection: %s", keys)
  }

  return nil, fmt.Errorf("interface {{ $interfaceType.Name }} was not matched against all PossibleTypes: %s", typeName)
}
{{-  end }}

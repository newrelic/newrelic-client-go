// Code generated by tutone: DO NOT EDIT
package {{.PackageName | lower}}
{{$packageName := .PackageName}}

{{- if gt (len .Imports) 0 }}
import(
  {{- range .Imports}}
  "{{.}}"
  {{- end}}
)
{{- end}}

{{range .Mutations}}
{{/*
// TODO The name of the method here could use some love. Perhaps we allow an
// override from the user at config time, so that we are able to replace what
// exists?  Perhps too this is an opporunity for us to use the method prefix as
// some kind of indicator for which package this method should belong to,
// perhaps.
*/}}
{{ .Description }}
func (a *{{$packageName|title}}) {{.Name | title}}(
  {{- range .Signature.Input}}
    {{.Name | untitle}} {{.Type}},
  {{- end}}
) (*{{ .Signature.Return | join ", "}}) {
  return a.{{.Name | title}}WithContext(context.Background(),
  {{- range .Signature.Input}}
    {{.Name | untitle}},
  {{- end}}
  )
}

{{ .Description }}
func (a *{{$packageName|title}}) {{.Name | title}}WithContext(
  ctx context.Context,
  {{- range .Signature.Input}}
    {{.Name | untitle}} {{.Type}},
  {{- end}}
    ) (*{{ .Signature.Return | join ", "}}) {

	resp := {{.Name}}QueryResponse{}
	vars := map[string]interface{}{
  {{- range .QueryVars}}
    "{{.Key}}": {{.Value | untitle}},
  {{- end}}
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, {{.Name}}Mutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.{{first .Signature.Return}}, nil
}

{{   if gt (len .QueryVars) 0 }}
type {{.Name}}QueryResponse struct {
  {{first .Signature.Return}} {{first .Signature.Return}} `json:"{{.Name}}"`
}
{{   end}}

const {{.Name}}Mutation = `{{ .QueryString }}`

{{ end}}

{{ range .Queries}}
{{ .Description }}
func (a *{{$packageName|title}}) Get{{.Name | title}}(
  {{- range .Signature.Input}}
    {{.Name | untitle}} {{.Type}},
  {{- end}}
) (*{{ .Signature.Return | join ", "}}) {
  return a.Get{{.Name | title}}WithContext(context.Background(),
  {{- range .Signature.Input}}
    {{.Name | untitle}},
  {{- end}}
  )
}

{{ .Description }}
func (a *{{$packageName|title}}) Get{{.Name | title}}WithContext(
  ctx context.Context,
  {{- range .Signature.Input}}
    {{.Name | untitle}} {{.Type}},
  {{- end}}
) (*{{ .Signature.Return | join ", "}}) {

	resp := {{.ResponseObjectType}}{}
	vars := map[string]interface{}{
  {{- range .QueryVars}}
    "{{.Key}}": {{.Value | untitle}},
  {{- end}}
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, get{{.Name}}Query, vars, &resp); err != nil {
		return nil, err
	}

  {{ if .Signature.ReturnSlice}}
	if len(resp.{{.Signature.ReturnPath | join "."}}.{{.Name}}) == 0 {
		return nil, errors.NewNotFound("")
	}
  {{- end}}

	return &resp.{{.Signature.ReturnPath | join "."}}.{{.Name}}, nil
}

const get{{.Name}}Query = `{{ .QueryString }}`

{{ end}}

// Code generated by tutone: DO NOT EDIT
package {{.PackageName | lower}}
{{$packageName := .PackageName}}

import(
  "fmt"
  {{- range .Imports}}
  "{{.}}"
  {{- end}}
)

{{range .Mutations}}
{{/*
// TODO The name of the method here could use some love. Perhaps we allow an
// override from the user at config time, so that we are able to replace what
// exists?  Perhps too this is an opporunity for us to use the method prefix as
// some kind of indicator for which package this method should belong to,
// perhaps.
*/}}
{{ .Description }}
func (a *{{$packageName|title}}) {{.Name | title}}(
  {{- range .Signature.Input}}
    {{.Name | untitle}} {{.Type}},
  {{- end}}
) (*{{ .Signature.Return | join ", "}}) {
  return a.{{.Name | title}}WithContext(context.Background(),
  {{- range .Signature.Input}}
    {{.Name | untitle}},
  {{- end}}
  )
}

{{ .Description }}
func (a *{{$packageName|title}}) {{.Name | title}}WithContext(
  ctx context.Context,
  {{- range .Signature.Input}}
    {{.Name | untitle}} {{.Type}},
  {{- end}}
    ) (*{{ .Signature.Return | join ", "}}) {

	resp := {{.Name}}QueryResponse{}
	vars := map[string]interface{}{
  {{- range .QueryVars}}
    "{{.Key}}": {{.Value | untitle}},
  {{- end}}
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, {{.Name}}Mutation, vars, &resp); err != nil {
		return nil, err
	}

  {{   if hasField (first .Signature.Return) "Errors" }}
  // If we got errors back, wrap them all up
  if len(resp.{{first .Signature.Return}}.Errors) > 0 {
    errs := fmt.Errorf("query error")
    for _, err := range resp.{{first .Signature.Return}}.Errors {
      errs = fmt.Errorf("%w; %s", errs, err.Description)
    }
    return nil, errs
  }
  {{   end}}

	return &resp.{{first .Signature.Return}}, nil
}

{{   if gt (len .QueryVars) 0 }}
type {{.Name}}QueryResponse struct {
  {{first .Signature.Return}} {{first .Signature.Return}} `json:"{{.Name}}"`
}
{{   end}}

const {{.Name}}Mutation = `{{ .QueryString }}`

{{ end}}

{{ range .Queries}}
{{ .Description }}
func (a *{{$packageName|title}}) Get{{.Name | title}}(
  {{- range .Signature.Input}}
    {{.Name | untitle}} {{.Type}},
  {{- end}}
) (*{{ .Signature.Return | join ", "}}) {
  return a.Get{{.Name | title}}WithContext(context.Background(),
  {{- range .Signature.Input}}
    {{.Name | untitle}},
  {{- end}}
  )
}

{{ .Description }}
func (a *{{$packageName|title}}) Get{{.Name | title}}WithContext(
  ctx context.Context,
  {{- range .Signature.Input}}
    {{.Name | untitle}} {{.Type}},
  {{- end}}
) (*{{ .Signature.Return | join ", "}}) {

	resp := {{.ResponseObjectType}}{}
	vars := map[string]interface{}{
  {{- range .QueryVars}}
    "{{.Key}}": {{.Value | untitle}},
  {{- end}}
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, get{{.Name}}Query, vars, &resp); err != nil {
		return nil, err
	}

  {{ if .Signature.ReturnSlice}}
	if len(resp.{{.Signature.ReturnPath | join "."}}.{{.Name}}) == 0 {
		return nil, errors.NewNotFound("")
	}
  {{- end}}

	return &resp.{{.Signature.ReturnPath | join "."}}.{{.Name}}, nil
}

const get{{.Name}}Query = `{{ .QueryString }}`

{{ end}}
